## 深层拷贝
> 1. 实现深层拷贝方法一
````javascript
function depClone(source) {
    return new Promise(resolve => {
        const {port1, port2} = new MessageChannel();
        port1.onmessage = ev => resolve(ev.data);
        port2.postMessage(source)
    })
}
````

> 1. 实现深层拷贝方法二
````javascript
var obj = {
    a: 1,
    b: [1, 2, 3],
    c: {
        d: 2,
        e: [{
            id: 1,
            name: '数据1'
        }, {
            id: 2,
            name: '数据2'
        }],
        f: {
            id: 22,
            name: 222
        }
    },
    g: undefined,
    h: null
}

function depClone(source) {
    if(!source || typeof source !== 'object') {
        return source
    }
    let result = source instanceof Array ? [] : {}
    for(let i in source) {
        result[i] = typeof source === 'object' ? depClone(source[i]) : source[i]
    }
}
````

#### 注意：
> 1. **for...in 循环用来枚举对象的属性**
> 2. **但是如果对象的属性值为undefined 或者 null，for...in语句会抛出错误，ECMAScript5更正了这一点，不会再抛出错误，而是不执行循环体。为了保证更大限度的兼容性，建议在使用for...in循环之前，先检测确认该属性值不是undefined或null。**
> 3. **Safari3以前版本的for...in语句中存在一个bug，该bug会导致某些属性被返回两次。**