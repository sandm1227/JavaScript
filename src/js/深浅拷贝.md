## 浅拷贝
>1. 只能拷贝一层，无论是数组还是对象
>2. 数组的浅拷贝方法：[].concat(arr)，slice(0), ...
>3. 对象的浅拷贝方法：...  Object.assign({}, obj1, obj2)

## 深层拷贝
>1. 对象的深拷贝，使用解析和序列化：JSON.parse(JSON.stringify(obj))
>2. 缺点：会忽略掉undefined 和 null
>3.      不能解析和序列化函数
>4.      不能解决循环引用的问题

> 实现深层拷贝方法一
````javascript
function depClone(source) {
    return new Promise(resolve => {
        const {port1, port2} = new MessageChannel();
        port1.onmessage = ev => resolve(ev.data);
        port2.postMessage(source)
    })
}
````

> 实现深层拷贝方法二
````javascript
var obj = {
    a: 1,
    b: [1, 2, 3],
    c: {
        d: 2,
        e: [{
            id: 1,
            name: '数据1'
        }, {
            id: 2,
            name: '数据2'
        }],
        f: {
            id: 22,
            name: 222
        }
    },
    g: undefined,
    h: null
}

function depClone(source) {
    if(!source || typeof source !== 'object') {
        return source
    }
    let result = source instanceof Array ? [] : {}
    for(let i in source) {
        result[i] = typeof source === 'object' ? depClone(source[i]) : source[i]
    }
    return result
}
````

> 实现深层拷贝方法三
````javascript
使用lodash里的深层拷贝方法
````

#### 注意：
>1. **for...in 循环用来枚举对象的属性**
>2. **但是如果对象的属性值为undefined 或者 null，for...in语句会抛出错误，ECMAScript5更正了这一点，不会再抛出错误，而是不执行循环体。为了保证更大限度的兼容性，建议在使用for...in循环之前，先检测确认该属性值不是undefined或null。**
>3. **Safari3以前版本的for...in语句中存在一个bug，该bug会导致某些属性被返回两次。**

#### 变态题：
>1. 一个对象是{key: value}格式，但里面具体有多少键值对和每个value是否都是object类型，都不清楚，输入一个要寻找的key数组keysArray，找出这些key对应的value值

````javascript
function getResult(obj, keys) {
    let tmp = {};
    for(let i = 0; i < keys.length; i++) {
        if(obj.hasOwnProperty(keys[i])) {
            tmp[keys[i]] = typeof obj[keys[i]] === 'object' ? depClone(obj[keys[i]]) : obj[keys[i]]
        } else {
            for (let i in obj) {
                getResult(obj[i], [keys[i]])
            }
        }
    }
    return tmp;
}
````